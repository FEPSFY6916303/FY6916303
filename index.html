<!DOCTYPE html>

<html>

  <head>
    <img src="WebBanner2023.png" alt="Banner" width="900" height="300">
  </head>

  <h1><b>ENG0018 Computer Laboratory 2025/26</b></h1>
  <h2>Student URN: 6916303</h2>
  <hr>

  
  <style>
.bg {
  position: fixed;       
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;           
  object-fit: cover;    
}
</style>
  <img src="Picture2.webp" class="bg">


  
  <head>
  <link href="https://fonts.cdnfonts.com/css/arcade-classic" rel="stylesheet" id="ArcadeClassic">
</head>
<style>
.arcade-text {
  font-family: 'ArcadeClassic', sans-serif;
  font-size: 50px;
  color: green; 
  text-shadow: 2px 2px black; 
  text-align: center;
}
</style>

  
  <h2 class="arcade-text"><b>Conference paper: The pursuit of Realistic Physics in Computer games</b></h2>



  <!style for tables>
  <style> 
    table {
      font-family:arial, sans-serif;
      border-collapse: collapse;
      width: 30%;

    }

    td, th {
      border: 1px solid #dddddd;
      text-align: left;
      padding: 8px;
    }

    tr:nth-child(even) {
      background-color: #dddddd;
    }


  </style>

  <style>
p.ex1 {
  color: green;
  font-size: 20px;
  text-align: left;
}
    </style>
</head>
  

  <meta name="viewport" content="width=device-width, initial-scale-1">
  <link rel="stylesheet"href="https://www.w3schools.com/w3css/4/w3.css>
  <style>
  .mySlides {display:none;}
  </style>

    <body style="background-color:#FFFFFF;margin-left:50px;">

  <!table of contents>
    <table>
    <tr>
     <th><h3>Table of contents</h3></th>
    </tr>
    <tr>
    <td><a href="#Abstract">Abstract</td>
</tr>
  <tr>
    <td><a href="#Introduction">Introduction</td>
  </tr>
  <tr>
    <td><a href="#First paragraph">First paragraph</td>
  </tr>
  <tr>
    <td><a href="#Second paragraph">Second paragraph</td>
  </tr>
  <tr>
    <td><a href="#Third paragraph">Third paragraph</td>
  </tr>
  <tr>
    <td><a href="#Conclusion">Conclusion</td>
  </tr>
  <tr>
    <td><a href="#References">References</td>
  </tr>
</table>
  
  <hr>
  <h3 id="Absract">Abstract</h3>
  <p class="ex1">
      <p>
      On Earth, would it make sense to sink into the ground when you intend to jump? Probably not. But it might not be impossible in another world, where jumping indeed means that you will sink into the ground. Everything that exists in a simulation must follow a consistent set of physical laws to be deemed as realistic in the environment. What good would it be if everything was out of order?
      </p>
  <p>
    Each game carries its own appeal which varies upon preference and whether it is conventional to Earth or not but collectively, when we click the download button, we carry expectations for how we believe the game should function. But there’s more to consider – developers don’t just provide players these unique experiences with ease. Many trials and components have been considered before launching the well-known titles players know and love today, with physics playing a key role.
  </p>

  
  <h3 id="Introduction">Introduction</h3>
  <p class="ex1" id="Introduction_InText">
      Physics engines are software developed by physicists for game developers, using math and logic to replicate real-world physical behaviour like collisions, movement and trajectory. Utilising real-world effects such as ragdoll physics and forces, game developers have been able to simulate various scenarios for players, propelling the industry to greater heights. The realism of video games has intensified over the years, with developers creating more immersive and dynamic worlds without having to code from scratch. But how exactly has this managed to come into fruition?
    </p>

  
  <h3 id="First paragraph">First paragraph</h3>
  <p class="ex1" id="Firstparagraph">
      When two objects in a video game collide, a certain reaction is elicited. This could be something as mediocre as a player bumping into the wall of a castle, meaning they are restricted from moving any further, or an enemy suffering from burning effects once struck by a fire spell. How does your game manage to seamlessly display these interactions without the player giving it a second thought? 
  <br>
    <br>
    Computer games follow similar processes for each interaction. Chris Hecker (2000) proposes four simple stages for displaying basic physical operations: contact detection, contact resolution, force computation and state integration. Contact detection, otherwise known as collision detection, determines when and how objects in an environment come into contact. Contact resolution is the process by which the physics engine decides the corresponding behaviour for all objects involved in the contact detection stage. Should they bounce back from one another? Should one object pass right through the other? To what degree are the objects affected by the collision? Force computation uses calculations to find the magnitude of the forces affecting the objects. Relevant physical variables are considered at this stage, such as velocity and momentum. Hecker also considers the interaction of force computation with collision detection, whereby objects exert a force on one another to prevent interpenetration when necessary. Finally, state integration implements the calculated forces acting on all the objects involved, rendering the finalised reaction on to the screen via the game’s graphics subsystem .
  </p>

  
  <h3 id="Second paragraph">Second paragraph</h3>
  <p class="ex1" id="Secondparagraph">
    The addition of a third dimension in video games has come with its trials – namely the issue of consistency. Sincell (1999) presents the idea that systems contain a series of predetermined causes and effects which occur with any given interaction. However, if an interaction exists outside these allowed possibilities, it will not happen at all. Interactions the player has with the environment have evolved since prerecorded animations which were commonly used in 2D games. Therefore, physics engines are unable to predict every possible collision down to the pixel, which often causes errors as many events are unforeseen in code.
  <br>
    <br>
    Complex objects within a simulation aren’t modelled wholly but are broken down into invisible geometric shapes such as spheres, rectangles or another complex polygon. More often known as ‘hitboxes’, these shapes register collisions between objects, which then triggers a response from the game engine and accordingly - the physics engine. The process is as follows: In a frame, once an overlap or collision is detected between a hitbox and a ‘hurtbox’ (the designated area that registers a hit), an event is triggered, which causes the physics engine to apply the general process mentioned above. 
  <br>
    <br>
The use of hitboxes has allowed video games to execute enhanced dynamic interactions. However, considerations must be made as the use of complex hitboxes comes at the cost of hardware resources. Therefore, developers must find a stable balance between performance and realism.
  <br>
    <br>
    Wiltshire (2000) comments on hitboxes existing simultaneously in space and time, creating a reaction which can be anticipated. Understanding hitboxes allows players to master the characteristics of physical laws of objects within a simulation. Hitbox implementation is, however, non-universal and varies between games.
  <br>
    <img src="Picture1.png" alt="Figure1" width="600" height="300">
    <br>
    For instance, Street Fighter V simulates ‘strike’ (offensive) hitboxes in red, as shown in the figure above. Hurtboxes are displayed in yellow and change shape depending on the character’s animation. Finally, the blue boxes represent physical positioning and detect contact. These are always active.
  </p>

  
  <h3 id="Third paragraph">Third paragraph</h3>
  <p class="ex1" id="Thirdparagraph">
    Many factors influence how seamlessly a game appears onscreen. A foundational example is simulation frequency. Simply put, this is how often a game or system updates the condition of objects per second, measured in hertz (Hz). The game engine observes these internal states  and consequently updates them every ‘simulation tick’, making them crucial for physics accuracy, performance and consistency. A higher frequency leads to smoother, more precise physics, but also increases the load on the GPU/CPU. 
  <br>
    <br>
    There are 2 types of simulation frequency: fixed and variable. Fixed frequency updates at a constant rate whereas variable frequency updates based on the time elapsed since the last frame. Whilst fixed frequencies enable predictable and stable physics to run across games, updates may be skipped if the system lags. Conversely whilst variable frequencies adapt to performance, it can also cause an instability in game physics.
  <br>
    <br>
    Unity is a game engine released in 2005, popular for its beginner-friendly architecture. One in a series of five articles, “Enhanced physics performance for smooth gameplay” (Unity, no date), unpacks the situation in which performance issues may occur due to abnormal frame preparation times. To avoid this issue, the article instructs users to decrease the ‘maximum allowed timestep ’. This limits the frequency of physics updates to implement smoother frames, at the cost of physics simulation accuracy. 
  </p>

  
<h3 id="Conclusion">Conclusion</h3>
  <p class="ex1" id="Conclusion">
    These are fragments of the operations that take place in the creation of video games. Many flaws still present themselves in production, however perfection is subjective. A perfect physics engine does not exist, but many developers continually improve year by year. Physics engines thrive in different aspects of creation, whether it’s balancing the computational limits of hardware, managing real-time constraints or balancing fun and performance with realism. As gaming technology evolves and developers master the components of engines, I believe they will create experiences which go above and beyond expectations that feel intuitive, immersive and fair to players.
  </p>
  

  <h3 id="References">References</h3>

  <p>
    Hecker, C. (2000) 'Physics in Computer Games’, New York: Association for Computing Machinery, Communications of the ACM, 2000-07, Vol.43 (7), p.34-39. Available at: Physics in computer games (title only) | Communications of the ACM (Accessed: 11/18/2025).
    Sincell, M. (1999) ' Physics Meets the Hideous Bog Beast’, Washington: American Society for the Advancement of Science, Science (American Association for the Advancement of Science), 1999-10, Vol.286 (5439), p.398-399. Available at: Physics meets the hideous bog beast - ProQuest (Accessed: 11/18/2025).
    Wiltshire, A. (2020) 'How hitboxes work, PC Gamer, Issue information, Page reference. Available at: How hitboxes work | PC Gamer (Accessed: 11/18/2025).
    Unity (no date) ‘Enhanced physics performance for smooth gameplay’. Available at: Enhanced physics performance for smooth gameplay | Unity (Accessed: 11/18/2025).
  </p>

  
<!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Adding last update ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
    <!-- Last commit time display -->
<div id="last-updated">Loading last update time...</div>
<!-- Verify Button -->
<button onclick="verifyLastUpdatedTime()" style="display: block; margin: 10px auto; padding: 8px 16px;">
    Verify Last Modified Time
</button>
<script>
    async function getLastUpdatedTime() {
        const username = 'FEPSFY6916303';
        const repo = 'FY6916303';
       
        const url = `https://api.github.com/repos/${username}/${repo}/commits`;
        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.github.v3+json',
                }
            });
            if (!response.ok) {
                throw new Error(`Error fetching data: ${response.status} - ${response.statusText}`);
            }
            const commits = await response.json();
            if (commits && commits.length > 0) {
                const lastCommitDate = new Date(commits[0].commit.committer.date);
               
                // Displaying the time on load
                document.getElementById('last-updated').innerText = `Last Modified Time: ${lastCommitDate.toLocaleString()}`;
            } else {
                document.getElementById('last-updated').innerText = 'No commits found in the repository.';
            }
        } catch (error) {
            console.error('Error fetching the last updated time:', error);
            document.getElementById('last-updated').innerText = 'Error fetching update time. Please check the repository details.';
        }
    }
    // Function to verify the last update time by re-fetching it from the API
    async function verifyLastUpdatedTime() {
        document.getElementById('last-updated').innerText = 'Verifying...';
        await getLastUpdatedTime();
        alert("Last modified time has been successfully verified from GitHub API.");
    }
    // Initial load to display the time on page load
    window.onload = getLastUpdatedTime;
</script>

  
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Word count function ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
<!-- Placeholder for total word count -->
<p id="totalWordCount"></p>
<hr>
<script>
  // Function to calculate and display word count for a specified section
  function displayWordCount(sectionId, outputId) {
    // Get the text content from the specified section
    const text = document.getElementById(sectionId).textContent;
    // Split text into words based on spaces and filter out any empty strings
    const wordArray = text.trim().split(/\s+/);
    // Count the words
    const wordCount = wordArray.length;
    // Return the word count for summing purposes
    return wordCount;
  }
  // Function to calculate and display total word count from selected sections
  function displayTotalWordCount() {
    // Calculate word count for each section and accumulate the total
    const IntroductionCount = displayWordCount("Introduction_InText");
    const FPCount = displayWordCount("Firstparagraph");
    const SPCount = displayWordCount("Secondparagraph");
    const TPCount = displayWordCount("Thirdparagraph");
    const ConclusionCount = displayWordCount("Conclusion");
    // Calculate the sum of all selected sections
    const totalWordCount = IntroductionCount + FPCount + SPCount + TPCount + Conclusion;
    // Display the total word count
    document.getElementById("totalWordCount").innerText = `Total word count: ${totalWordCount}`;
  }
  // Run the function for specific sections and display total count when the page loads
  window.onload = displayTotalWordCount;
</script>

  </body>
</html>

  
</head>
                                                                                
</html>

